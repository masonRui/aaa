package cn.itheima.polymorphismTest;

public class Child extends Father{
    //构造方法是用来初始化变量的。当子类继承父类的时候，默认在最上方调用了父类的构造方法，但这个不是继承，
    //默认在最上方有个super();如果父类没有空参的构造方法，则编译器报错，这时需要我们在子类中写一个和父类的构造
    //方法 方法签名一致的构造方法，因为子类继承了父类的变量，而父类的变量在父类是必须在构造的时候初始化，所以子类
    //也必须将其初始化。也说明了如果方法中有了构造方法，就不会有默认构造方法；
    //同时，此时不允许子类有默认构造方法，因为这会导致和上面同样的问题，就是变量没有初始化。

    //复习下final，final修饰的类无法被继承叫太监类，
    //final修饰的方法无法被重写，但可以被继承。
    //final修饰的变量只能被赋值一次，但如果是成员变量可以更改成员变量的属性，只要不改变地址即可。
    //final修饰的成员变量可以由两种赋值方式，一种是直接赋值，一种是通过构造方法赋值
    //final修饰的变量叫常量。

    //继承的时候继承了父类的方法（包括final），但不能继承构造方法，

    //复习接口
    //接口里面没有变量，有常量，有抽象方法，默认方法，静态方法和私有方法。
    //当多实现时，如果有抽象方法，必须实现（好像怎么样都是必须实现）
    //当多实现时，有默认方法重名，必须重写默认方法，不然实现类调用时，无法确定调哪个
    //多实现时，静态方法重名，不用管，因为静态方法属于类，用类名直接调用。
    //多实现时，私有方法无需多管。

    //静态代码块用于初始化和 设置什么东西，忘记了 ，接口中能有静态代码块么？
    //静态代码块时给静态变量赋值的，还有个作用时加载数据库驱动的,示例代码如下，参考DriverManager类
    /*static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }*/
    //静态代码块不能在接口中。
    //静态代码块和静态方法中都不能使用this，super，因为这俩都是指向对象的，而此时对象还没有生成

    //多态的弊端，不能调用子类特有方法

    //四大权限修饰符 public protected  (default)  private
    //protected和默认的区别时protected有个继承关系访问权限，被该修饰符修饰的方法，可以被其他包中它的子类访问
    //但默认访问修饰符，又叫包访问修饰符，只能在包内访问。
    public Child(String name) {
        super(name);
       // this.name =name;同样，父类的name设置私有，也不能用其他方法更改此属性，只能由super调用父类的默认方法。
    }



    /*@Override
    public void show() {
        System.out.println("child show");
    }*/
}
